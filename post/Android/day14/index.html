<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/profile_cute.png"/><link rel="stylesheet" href="/_next/static/css/fff7d7d50ba66cff.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c5f8510880a90daa.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-c50cb70e7323352b.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-0c59dfdc78baeb85.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-baff347ce7e39457.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-069982e43c2ae463.js" async=""></script><script src="/_next/static/chunks/app/layout-10c7e025b6149e17.js" async=""></script><script src="/_next/static/chunks/app/page-e31ae51de7be232e.js" async=""></script><title>jinwk note</title><meta name="description" content="jinwk dev note"/><script>
              (function() {
                try {
                  const savedTheme = localStorage.getItem('theme');
                  // Default to 'dark' if no save found, ignoring system preference for now to start dark
                  const theme = savedTheme || 'dark';
                  document.documentElement.setAttribute('data-theme', theme);
                } catch (e) {}
              })();
            </script><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><div class="app-container"><aside class="sidebar"><div class="profile-section"><div class="profile-img-wrapper"><img src="/profile_cute.png" alt="Profile" class="profile-img"/></div><div class="profile-name" style="display:flex;align-items:center;justify-content:center;gap:0.5rem">jinwook yu<a style="font-size:0.9rem;opacity:0.5;text-decoration:none" href="/admin/">⚙️</a></div><div class="profile-subtitle" style="font-size:0.9rem;color:var(--text-muted);margin-bottom:1rem">dbwlsdnr95</div><div class="profile-bio" style="white-space:pre-line;font-size:0.85rem;text-align:left;width:100%">웹·모바일 진단 ,솔루션 운영 및 클라우드 보안을 경험했고, 현재는 모의해킹·취약점 분석·CVE 연구에 집중하고 있습니다. 실전 기반 보안 역량을 꾸준히 확장하고 있습니다.</div></div><nav class="nav-section"><div class="nav-title">분류 전체보기</div><ul class="nav-list" style="margin-bottom:2rem"><li class="nav-item"><a class="" href="/">전체보기</a></li></ul><div style="margin-bottom:2rem"><div class="nav-title">교육</div><ul class="nav-list"><li class="nav-item"><a class="" href="/category/Android/">Android</a></li><li class="nav-item"><a class="" href="/category/JAVA/">JAVA</a></li><li class="nav-item"><a class="" href="/category/AWS/">AWS</a></li></ul></div></nav></aside><main class="main-content"><article class="article-container"><div class="article-header"><span class="article-category">Android</span><h1 class="article-title">Android 보안 14일차</h1></div><div class="article-content"><h1>JNI (Java Native Interface) 정리</h1>
<h2>1. JNI 개요</h2>
<h3>JNI란?</h3>
<ul>
<li><strong>Java/Kotlin ↔ C/C++</strong> 간의 상호 호출을 가능하게 하는 인터페이스</li>
<li>Android에서 <strong>Native 코드(.so)</strong> 를 사용하기 위한 표준 방식</li>
</ul>
<h3>기본 구조</h3>
<ul>
<li>Java/Kotlin → JNI → C/C++</li>
<li>Native 라이브러리 형태: <code>.so</code></li>
</ul>
<hr>
<h2>2. 개발 환경 구축</h2>
<h3>Android Studio</h3>
<ul>
<li>Android 앱 개발용 공식 IDE</li>
<li>에뮬레이터는 사용하지 않음 (NOX 사용)</li>
</ul>
<h3>Ghidra</h3>
<ul>
<li>오픈소스 리버싱 도구</li>
<li>다운로드
<ul>
<li>Google 검색: <code>ghidra github</code></li>
<li>Release 버전 다운로드</li>
</ul>
</li>
<li>실행
<ul>
<li>압축 해제</li>
<li><code>ghidraRun.bat</code> 실행</li>
</ul>
</li>
</ul>
<h3>Java 환경 오류 해결</h3>
<ul>
<li>오류 예시
<ul>
<li><code>JAVA_HOME</code></li>
<li><code>java version not found</code></li>
</ul>
</li>
<li>해결 방법
<ol>
<li>기존 Java 삭제</li>
<li><strong>OpenJDK 재설치</strong></li>
<li>설치 옵션 전체 선택</li>
<li><code>JAVA_HOME</code> 자동 설정 확인</li>
</ol>
</li>
</ul>
<h3>OpenJDK 다운로드</h3>
<ul>
<li>https://adoptium.net/</li>
</ul>
<hr>
<h2>3. NOX + ADB 환경 구성</h2>
<h3>ADB 파일 교체 이유</h3>
<ul>
<li>NOX 기본 ADB가 불안정</li>
<li>Android Studio ADB로 교체 필요</li>
</ul>
<h3>원본 ADB 경로</h3>
<pre><code>C:\Users\사용자\AppData\Local\Android\Sdk\platform-tools\
</code></pre>
<h3>복사 대상 파일</h3>
<ul>
<li>adb.exe</li>
<li>AdbWinApi.dll</li>
<li>AdbWinUsbApi.dll</li>
</ul>
<h3>NOX 경로</h3>
<pre><code>C:\Program Files (x86)\Nox\bin\
</code></pre>
<h3>적용 방법</h3>
<ul>
<li>기존 파일 덮어쓰기</li>
<li><code>adb.exe</code> 복사 → 이름 변경 → <code>nox_adb.exe</code></li>
</ul>
<hr>
<h2>4. NOX USB 디버깅 활성화</h2>
<ol>
<li>NOX 설정 → 시스템 → 태블릿 정보</li>
<li><strong>빌드 번호 연속 클릭</strong></li>
<li>개발자 모드 활성화</li>
<li>고급 설정 → 개발자 옵션</li>
<li>USB 디버깅 활성화</li>
</ol>
<hr>
<h2>5. Android 프로젝트 생성</h2>
<h3>프로젝트 설정</h3>
<ul>
<li>App Name: <code>testapp</code></li>
<li>Package Name: <code>kr.seyong.testapp</code></li>
<li>SDK: 24</li>
<li>Language: Java</li>
<li>Native(C/C++): 기본 옵션</li>
<li>Finish</li>
</ul>
<hr>
<h2>6. 설치된 앱 추출</h2>
<pre><code>adb shell
pm list packages -f | grep 패키지명
</code></pre>
<hr>
<h2>7. Java와 C 문자열 차이</h2>
<h3>Java String</h3>
<pre><code>String a = new String("abcd");
</code></pre>
<ul>
<li>객체</li>
<li>JVM Heap에 저장</li>
</ul>
<h3>C String</h3>
<pre><code>char* a = {'a','b','c','d','\0'};
</code></pre>
<ul>
<li>Null 종료 문자열</li>
<li>메모리 직접 관리</li>
</ul>
<hr>
<h2>8. JNI를 사용하는 이유</h2>
<h3>Google 권장</h3>
<ul>
<li>“가능하면 JNI 쓰지 마라”</li>
<li>Kotlin / Java API로 대부분 해결 가능</li>
</ul>
<h3>그럼에도 JNI를 쓰는 이유</h3>
<ol>
<li><strong>성능</strong>
<ul>
<li>게임</li>
<li>그래픽</li>
<li>하드웨어 연산</li>
</ul>
</li>
<li><strong>OS 레벨 접근</strong>
<ul>
<li>파일 시스템</li>
<li>저수준 연산</li>
</ul>
</li>
<li><strong>보안</strong>
<ul>
<li>코드 은닉 목적</li>
<li>리버싱 난이도 상승</li>
</ul>
</li>
</ol>
<h3>보안 솔루션</h3>
<ul>
<li>모바일 보안 솔루션 대부분 JNI 사용</li>
<li>Native 레벨에서 무결성 / 탐지 수행</li>
</ul>
<hr>
<h2>9. JVM vs Native 실행 구조</h2>
<h3>Java / Kotlin</h3>
<ul>
<li>JVM 위에서 실행</li>
<li>Cross-platform</li>
<li>동일 APK → 모든 기기 실행 가능</li>
</ul>
<h3>Native (C/C++)</h3>
<ul>
<li>OS / 아키텍처 의존</li>
<li>환경별 빌드 필요</li>
</ul>
<p>| 환경    | 결과           |
| ------- | -------------- |
| Windows | <code>.exe</code>, <code>.dll</code> |
| Linux   | ELF, <code>.so</code>     |
| Android | <code>.so</code>          |</p>
<hr>
<h2>10. ABI와 Native 라이브러리</h2>
<h3>ABI 종류</h3>
<ul>
<li>arm</li>
<li>arm64-v8a</li>
<li>x86</li>
<li>x86_64</li>
</ul>
<h3>기본 포함 구조</h3>
<ul>
<li>각 ABI별 <code>.so</code> 파일 필요</li>
<li>32bit / 64bit 에뮬레이터 별도 대응</li>
</ul>
<hr>
<h2>11. JNI 라이브러리 로딩</h2>
<h3>System.loadLibrary</h3>
<pre><code>System.loadLibrary("test");
</code></pre>
<ul>
<li>실제 로드 파일</li>
</ul>
<pre><code>libtest.so
</code></pre>
<ul>
<li>APK 내부 <code>/lib/&#x3C;abi>/libtest.so</code></li>
</ul>
<h3>System.load</h3>
<pre><code>System.load("/sdcard/android/data/lib/arm64/libtest.so");
</code></pre>
<hr>
<h2>12. JNI 기본 코드 구조</h2>
<h3>Java 코드</h3>
<pre><code>class MainActivity {

    static {
        System.loadLibrary("testapp");
    }

    public native void callJni();
}
</code></pre>
<h3>Native 함수 시그니처</h3>
<pre><code>Java_kr_seyong_testapp_MainActivity_callJni(
    JNIEnv* env,
    jobject thiz
) {
    // Native 로직
}
</code></pre>
<hr>
<h2>13. JNI_OnLoad &#x26; RegisterNative</h2>
<h3>JNI_OnLoad</h3>
<ul>
<li>라이브러리 로드 시 자동 실행</li>
<li>Native 함수 등록 가능</li>
</ul>
<pre><code>JNI_OnLoad(JavaVM* vm, void* reserved) {
    // RegisterNativeMethods
}
</code></pre>
<hr>
<h2>14. 문자열 비교 (보안 핵심)</h2>
<h3>Java</h3>
<pre><code>String a = "aaa";
String b = "bbb";

if (a == b) {
    // 주소 비교
}

if (a.equals(b)) {
    // 값 비교
}
</code></pre>
<h3>C / C++</h3>
<pre><code>strcmp(a, b); // 값 비교
std::string a = "aaa";
std::string b = "aaa";

if (a == b) // 주소 비교 (의도와 다를 수 있음)
</code></pre>
<hr>
<h2>15. 인증 로직 예시</h2>
<pre><code>private boolean checkPassword(String pw) {
    if (pw.equals("hacker")) {
        return true;
    } else {
        return false;
    }
}
</code></pre>
<ul>
<li>JNI에서 이런 로직을 처리하면
<ul>
<li>Java 코드 노출 감소</li>
<li>리버싱 난이도 증가</li>
</ul>
</li>
</ul>
<hr>
<h2>16. 보안 관점 정리</h2>
<ul>
<li>JNI는 <strong>성능 + 보안 목적</strong></li>
<li>Native 코드도 결국 리버싱 가능</li>
<li>Ghidra / IDA로 분석 가능</li>
<li>Frida와 결합 시 동적 우회 가능</li>
</ul>
<hr>
<h3>요약 한 줄</h3>
<blockquote>
<p>JNI는 성능과 보안을 위해 사용되며, Java/Kotlin과 Native 간의 경계를 이해하는 것이 모바일 보안 분석의 핵심이다.</p>
</blockquote>
</div></article></main></div><script src="/_next/static/chunks/webpack-c5f8510880a90daa.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/fff7d7d50ba66cff.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[7690,[],\"\"]\n6:I[5613,[],\"\"]\n9:I[1778,[],\"\"]\na:I[8383,[\"250\",\"static/chunks/250-069982e43c2ae463.js\",\"185\",\"static/chunks/app/layout-10c7e025b6149e17.js\"],\"\"]\nb:I[5250,[\"250\",\"static/chunks/250-069982e43c2ae463.js\",\"931\",\"static/chunks/app/page-e31ae51de7be232e.js\"],\"\"]\nd:I[8955,[],\"\"]\n7:[\"category\",\"Android\",\"d\"]\n8:[\"slug\",\"day14\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fff7d7d50ba66cff.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"16MaIM6sfU5RrcCsiLE0O\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/post/Android/day14/\",\"initialTree\":[\"\",{\"children\":[\"post\",{\"children\":[[\"category\",\"Android\",\"d\"],{\"children\":[[\"slug\",\"day14\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"Android\\\",\\\"slug\\\":\\\"day14\\\"}\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"post\",{\"children\":[[\"category\",\"Android\",\"d\"],{\"children\":[[\"slug\",\"day14\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L4\",\"$L5\",null]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\",\"$7\",\"children\",\"$8\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\",\"$7\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              (function() {\\n                try {\\n                  const savedTheme = localStorage.getItem('theme');\\n                  // Default to 'dark' if no save found, ignoring system preference for now to start dark\\n                  const theme = savedTheme || 'dark';\\n                  document.documentElement.setAttribute('data-theme', theme);\\n                } catch (e) {}\\n              })();\\n            \"}}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app-container\",\"children\":[[\"$\",\"$La\",null,{\"categories\":[\"AWS\",\"Android\",\"JAVA\"]}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center min-h-[60vh] text-center px-4\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-4xl font-bold mb-4\",\"children\":\"404 - Not Found\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-500 mb-8\",\"children\":\"요청하신 페이지를 찾을 수 없습니다.\"}],[\"$\",\"$Lb\",null,{\"href\":\"/\",\"className\":\"px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition\",\"children\":\"홈으로 돌아가기\"}]]}],\"notFoundStyles\":[],\"styles\":null}]}]]}]}]]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"f:T19f3,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJNI (Java Native Interface) 정리\u003c/h1\u003e\n\u003ch2\u003e1. JNI 개요\u003c/h2\u003e\n\u003ch3\u003eJNI란?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJava/Kotlin ↔ C/C++\u003c/strong\u003e 간의 상호 호출을 가능하게 하는 인터페이스\u003c/li\u003e\n\u003cli\u003eAndroid에서 \u003cstrong\u003eNative 코드(.so)\u003c/strong\u003e 를 사용하기 위한 표준 방식\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e기본 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eJava/Kotlin → JNI → C/C++\u003c/li\u003e\n\u003cli\u003eNative 라이브러리 형태: \u003ccode\u003e.so\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 개발 환경 구축\u003c/h2\u003e\n\u003ch3\u003eAndroid Studio\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAndroid 앱 개발용 공식 IDE\u003c/li\u003e\n\u003cli\u003e에뮬레이터는 사용하지 않음 (NOX 사용)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGhidra\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e오픈소스 리버싱 도구\u003c/li\u003e\n\u003cli\u003e다운로드\n\u003cul\u003e\n\u003cli\u003eGoogle 검색: \u003ccode\u003eghidra github\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eRelease 버전 다운로드\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e실행\n\u003cul\u003e\n\u003cli\u003e압축 해제\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eghidraRun.bat\u003c/code\u003e 실행\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eJava 환경 오류 해결\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e오류 예시\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eJAVA_HOME\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejava version not found\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e해결 방법\n\u003col\u003e\n\u003cli\u003e기존 Java 삭제\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOpenJDK 재설치\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e설치 옵션 전체 선택\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eJAVA_HOME\u003c/code\u003e 자동 설정 확인\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eOpenJDK 다운로드\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ehttps://adoptium.net/\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e3. NOX + ADB 환경 구성\u003c/h2\u003e\n\u003ch3\u003eADB 파일 교체 이유\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNOX 기본 ADB가 불안정\u003c/li\u003e\n\u003cli\u003eAndroid Studio ADB로 교체 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e원본 ADB 경로\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eC:\\Users\\사용자\\AppData\\Local\\Android\\Sdk\\platform-tools\\\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e복사 대상 파일\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eadb.exe\u003c/li\u003e\n\u003cli\u003eAdbWinApi.dll\u003c/li\u003e\n\u003cli\u003eAdbWinUsbApi.dll\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNOX 경로\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eC:\\Program Files (x86)\\Nox\\bin\\\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e적용 방법\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e기존 파일 덮어쓰기\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eadb.exe\u003c/code\u003e 복사 → 이름 변경 → \u003ccode\u003enox_adb.exe\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e4. NOX USB 디버깅 활성화\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eNOX 설정 → 시스템 → 태블릿 정보\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e빌드 번호 연속 클릭\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e개발자 모드 활성화\u003c/li\u003e\n\u003cli\u003e고급 설정 → 개발자 옵션\u003c/li\u003e\n\u003cli\u003eUSB 디버깅 활성화\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2\u003e5. Android 프로젝트 생성\u003c/h2\u003e\n\u003ch3\u003e프로젝트 설정\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eApp Name: \u003ccode\u003etestapp\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ePackage Name: \u003ccode\u003ekr.seyong.testapp\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSDK: 24\u003c/li\u003e\n\u003cli\u003eLanguage: Java\u003c/li\u003e\n\u003cli\u003eNative(C/C++): 기본 옵션\u003c/li\u003e\n\u003cli\u003eFinish\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e6. 설치된 앱 추출\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eadb shell\r\npm list packages -f | grep 패키지명\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e7. Java와 C 문자열 차이\u003c/h2\u003e\n\u003ch3\u003eJava String\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eString a = new String(\"abcd\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e객체\u003c/li\u003e\n\u003cli\u003eJVM Heap에 저장\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eC String\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003echar* a = {'a','b','c','d','\\0'};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eNull 종료 문자열\u003c/li\u003e\n\u003cli\u003e메모리 직접 관리\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e8. JNI를 사용하는 이유\u003c/h2\u003e\n\u003ch3\u003eGoogle 권장\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e“가능하면 JNI 쓰지 마라”\u003c/li\u003e\n\u003cli\u003eKotlin / Java API로 대부분 해결 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e그럼에도 JNI를 쓰는 이유\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e성능\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e게임\u003c/li\u003e\n\u003cli\u003e그래픽\u003c/li\u003e\n\u003cli\u003e하드웨어 연산\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOS 레벨 접근\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e파일 시스템\u003c/li\u003e\n\u003cli\u003e저수준 연산\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e보안\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e코드 은닉 목적\u003c/li\u003e\n\u003cli\u003e리버싱 난이도 상승\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e보안 솔루션\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e모바일 보안 솔루션 대부분 JNI 사용\u003c/li\u003e\n\u003cli\u003eNative 레벨에서 무결성 / 탐지 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e9. JVM vs Native 실행 구조\u003c/h2\u003e\n\u003ch3\u003eJava / Kotlin\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eJVM 위에서 실행\u003c/li\u003e\n\u003cli\u003eCross-platform\u003c/li\u003e\n\u003cli\u003e동일 APK → 모든 기기 실행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNative (C/C++)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eOS / 아키텍처 의존\u003c/li\u003e\n\u003cli\u003e환경별 빌드 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e| 환경    | 결과           |\r\n| ------- | -------------- |\r\n| Windows | \u003ccode\u003e.exe\u003c/code\u003e, \u003ccode\u003e.dll\u003c/code\u003e |\r\n| Linux   | ELF, \u003ccode\u003e.so\u003c/code\u003e     |\r\n| Android | \u003ccode\u003e.so\u003c/code\u003e          |\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e10. ABI와 Native 라이브러리\u003c/h2\u003e\n\u003ch3\u003eABI 종류\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003earm\u003c/li\u003e\n\u003cli\u003earm64-v8a\u003c/li\u003e\n\u003cli\u003ex86\u003c/li\u003e\n\u003cli\u003ex86_64\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e기본 포함 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e각 ABI별 \u003ccode\u003e.so\u003c/code\u003e 파일 필요\u003c/li\u003e\n\u003cli\u003e32bit / 64bit 에뮬레이터 별도 대응\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e11. JNI 라이브러리 로딩\u003c/h2\u003e\n\u003ch3\u003eSystem.loadLibrary\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eSystem.loadLibrary(\"test\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e실제 로드 파일\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003elibtest.so\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eAPK 내부 \u003ccode\u003e/lib/\u0026#x3C;abi\u003e/libtest.so\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSystem.load\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eSystem.load(\"/sdcard/android/data/lib/arm64/libtest.so\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e12. JNI 기본 코드 구조\u003c/h2\u003e\n\u003ch3\u003eJava 코드\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eclass MainActivity {\r\n\r\n    static {\r\n        System.loadLibrary(\"testapp\");\r\n    }\r\n\r\n    public native void callJni();\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eNative 함수 시그니처\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eJava_kr_seyong_testapp_MainActivity_callJni(\r\n    JNIEnv* env,\r\n    jobject thiz\r\n) {\r\n    // Native 로직\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e13. JNI_OnLoad \u0026#x26; RegisterNative\u003c/h2\u003e\n\u003ch3\u003eJNI_OnLoad\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e라이브러리 로드 시 자동 실행\u003c/li\u003e\n\u003cli\u003eNative 함수 등록 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eJNI_OnLoad(JavaVM* vm, void* reserved) {\r\n    // RegisterNativeMethods\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e14. 문자열 비교 (보안 핵심)\u003c/h2\u003e\n\u003ch3\u003eJava\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eString a = \"aaa\";\r\nString b = \"bbb\";\r\n\r\nif (a == b) {\r\n    // 주소 비교\r\n}\r\n\r\nif (a.equals(b)) {\r\n    // 값 비교\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eC / C++\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003estrcmp(a, b); // 값 비교\r\nstd::string a = \"aaa\";\r\nstd::string b = \"aaa\";\r\n\r\nif (a == b) // 주소 비교 (의도와 다를 수 있음)\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e15. 인증 로직 예시\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eprivate boolean checkPassword(String pw) {\r\n    if (pw.equals(\"hacker\")) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eJNI에서 이런 로직을 처리하면\n\u003cul\u003e\n\u003cli\u003eJava 코드 노출 감소\u003c/li\u003e\n\u003cli\u003e리버싱 난이도 증가\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e16. 보안 관점 정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eJNI는 \u003cstrong\u003e성능 + 보안 목적\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eNative 코드도 결국 리버싱 가능\u003c/li\u003e\n\u003cli\u003eGhidra / IDA로 분석 가능\u003c/li\u003e\n\u003cli\u003eFrida와 결합 시 동적 우회 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e요약 한 줄\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJNI는 성능과 보안을 위해 사용되며, Java/Kotlin과 Native 간의 경계를 이해하는 것이 모바일 보안 분석의 핵심이다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"article-container\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":\"Android\"}],[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Android 보안 14일차\"}]]}],[\"$\",\"div\",null,{\"className\":\"article-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]]}]\nc:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"titl"])</script><script>self.__next_f.push([1,"e\",\"2\",{\"children\":\"jinwk note\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"jinwk dev note\"}]]\n4:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>