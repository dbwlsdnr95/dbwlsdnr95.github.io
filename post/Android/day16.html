<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/profile_cute.png"/><link rel="stylesheet" href="/_next/static/css/fff7d7d50ba66cff.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c5f8510880a90daa.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-c50cb70e7323352b.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-f8546037c2082669.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-baff347ce7e39457.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-069982e43c2ae463.js" async=""></script><script src="/_next/static/chunks/app/layout-10c7e025b6149e17.js" async=""></script><script src="/_next/static/chunks/app/page-e31ae51de7be232e.js" async=""></script><title>jinwk note</title><meta name="description" content="jinwk dev note"/><script>
              (function() {
                try {
                  const savedTheme = localStorage.getItem('theme');
                  // Default to 'dark' if no save found, ignoring system preference for now to start dark
                  const theme = savedTheme || 'dark';
                  document.documentElement.setAttribute('data-theme', theme);
                } catch (e) {}
              })();
            </script><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><div class="app-container"><aside class="sidebar"><div class="profile-section"><div class="profile-img-wrapper"><img src="/profile_cute.png" alt="Profile" class="profile-img"/></div><div class="profile-name" style="display:flex;align-items:center;justify-content:center;gap:0.5rem">jinwook yu<a style="font-size:0.9rem;opacity:0.5;text-decoration:none" href="/admin">⚙️</a></div><div class="profile-subtitle" style="font-size:0.9rem;color:var(--text-muted);margin-bottom:1rem">dbwlsdnr95</div><div class="profile-bio" style="white-space:pre-line;font-size:0.85rem;text-align:left;width:100%">웹·모바일 진단 ,솔루션 운영 및 클라우드 보안을 경험했고, 현재는 모의해킹·취약점 분석·CVE 연구에 집중하고 있습니다. 실전 기반 보안 역량을 꾸준히 확장하고 있습니다.</div></div><nav class="nav-section"><div class="nav-title">분류 전체보기</div><ul class="nav-list" style="margin-bottom:2rem"><li class="nav-item"><a class="" href="/">전체보기</a></li></ul><div style="margin-bottom:2rem"><div class="nav-title">교육</div><ul class="nav-list"><li class="nav-item"><a class="" href="/category/Android">Android</a></li><li class="nav-item"><a class="" href="/category/JAVA">JAVA</a></li><li class="nav-item"><a class="" href="/category/AWS">AWS</a></li></ul></div></nav></aside><main class="main-content"><article class="article-container"><div class="article-header"><span class="article-category">Android</span><h1 class="article-title">Android 보안 16일차</h1></div><div class="article-content"><h1>JNI (Java Native Interface) 정리</h1>
<h2>1. JNI 개념</h2>
<h3>JNI란?</h3>
<ul>
<li><strong>Java/Kotlin ↔ C/C++</strong> 를 연결하는 인터페이스</li>
<li>Android 앱에서 Native 코드(<code>.so</code>)를 사용하기 위한 표준 방식</li>
</ul>
<h3>JNI를 사용하는 이유</h3>
<ul>
<li><strong>성능</strong>
<ul>
<li>VM 위가 아닌 Native에서 직접 연산</li>
<li>게임, 그래픽, 대규모 연산</li>
</ul>
</li>
<li><strong>기존 라이브러리 활용</strong>
<ul>
<li>이미 만들어진 C/C++ 라이브러리 재사용</li>
</ul>
</li>
<li><strong>메모리 직접 제어</strong>
<ul>
<li>GC 영향 없이 직접 관리</li>
</ul>
</li>
<li><strong>보안</strong>
<ul>
<li>Java 코드보다 리버싱 난이도 상승</li>
<li>금융 앱, 게임, 보안 솔루션에서 다수 사용</li>
</ul>
</li>
</ul>
<hr>
<h2>2. Java / Native 실행 구조 비교</h2>
<h3>Java / Kotlin</h3>
<ul>
<li>JVM 위에서 실행</li>
<li>Cross-platform</li>
<li>코드 하나로 모든 기기에서 실행 가능</li>
</ul>
<h3>Native (C/C++)</h3>
<ul>
<li>OS / 아키텍처 의존</li>
<li>환경별로 빌드 필요</li>
</ul>
<p>| 환경    | 결과           |
| ------- | -------------- |
| Windows | <code>.exe</code>, <code>.dll</code> |
| Linux   | ELF, <code>.so</code>     |
| Android | <code>.so</code> (ABI별)  |</p>
<hr>
<h2>3. JNI 함수 연결 방식</h2>
<h3>Java 쪽</h3>
<pre><code>public native boolean checkPassword(String pw);
</code></pre>
<h3>Native 쪽 (기본 네이밍)</h3>
<pre><code>Java_패키지명_클래스명_함수명
</code></pre>
<p>예:</p>
<pre><code>Java_kr_seyong_test_MainActivity_checkPassword
</code></pre>
<h3>System.load / loadLibrary</h3>
<pre><code>System.loadLibrary("test");   // libtest.so
System.load("/sdcard/.../libtest.so");
</code></pre>
<ul>
<li>라이브러리 로딩 시 <code>JNI_OnLoad</code> 실행 가능</li>
</ul>
<hr>
<h2>4. RegisterNative 방식</h2>
<ul>
<li>함수 이름을 직접 매핑</li>
<li>Java 함수명 ≠ Native 함수명 가능</li>
</ul>
<pre><code>JNI_OnLoad() {
    RegisterNativeMethods(
        Java test() → C qqqq()
    );
}
</code></pre>
<ul>
<li>Ghidra에서 함수명이 난독화되어 보이는 이유</li>
</ul>
<hr>
<h2>5. Android / iOS 리버싱 구조 비교</h2>
<h3>Android</h3>
<ul>
<li>APK = ZIP</li>
<li><code>classes.dex → smali → java (jadx)</code></li>
<li>Native: <code>.so</code> → Ghidra / IDA</li>
</ul>
<h3>iOS</h3>
<ul>
<li>IPA = ZIP</li>
<li><code>Info.plist</code></li>
<li>Binary 추출 후 Ghidra / IDA</li>
<li>탈옥 환경: Cydia, Zebra, Sileo</li>
<li>설치: appinst, 3uTools, appsync</li>
</ul>
<hr>
<h2>6. Native 메모리 구조와 Offset</h2>
<h3>메모리 배치 개념</h3>
<pre><code>libc.so        libandroid.so        libtest.so
[            ][                  ][            ]
base                            base
</code></pre>
<h3>Offset 개념</h3>
<ul>
<li>base 주소로부터 떨어진 거리</li>
</ul>
<pre><code>실제 함수 주소 = module.base + offset
</code></pre>
<p>예:</p>
<pre><code>base   = 0x00100000
offset = 0x000243c0
addr   = 0x001243c0
</code></pre>
<hr>
<h2>7. JNI Native 코드 예제 (Ghidra 기준)</h2>
<pre><code>bool Java_kr_seyong_test_MainActivity_checkPassword(
    JNIEnv *env,
    jobject thiz,
    jstring pw
) {
    int ret;
    char* nativeStr;

    nativeStr = env->GetStringUTFChars(pw, 0);
    ret = strcmp(nativeStr, "hacker");
    env->ReleaseStringUTFChars(pw, nativeStr);

    return ret == 0;
}
</code></pre>
<h3>핵심</h3>
<ul>
<li><code>jstring → char*</code></li>
<li><code>strcmp</code> 결과로 인증 판단</li>
</ul>
<hr>
<h2>8. Frida Native 후킹 기본 구조</h2>
<h3>라이브러리 &#x26; 함수 주소 찾기</h3>
<pre><code>var lib = Process.findModuleByName("libtest.so");

// 1. 함수명 기반
var funcAddr = lib.findExportByName(
  "Java_kr_seyong_test_MainActivity_checkPassword"
);

// 2. 오프셋 기반
var funcAddr = lib.base.add(0x243c0);
</code></pre>
<hr>
<h2>9. Interceptor.attach (함수 후킹)</h2>
<h3>실행 흐름</h3>
<ul>
<li><strong>onEnter</strong>: 함수 진입 시</li>
<li><strong>onLeave</strong>: 리턴 직전</li>
</ul>
<pre><code>Interceptor.attach(funcAddr, {
    onEnter: function (args) {
        /*
          args[0] = JNIEnv*
          args[1] = jobject (this)
          args[2] = jstring (pw)
        */
    },
    onLeave: function (retval) {
    }
});
</code></pre>
<hr>
<h2>10. jstring 값 읽기</h2>
<pre><code>var env = Java.vm.getEnv();
var pw = env.getStringUtfChars(args[2], null).readCString();
console.log(pw);
</code></pre>
<hr>
<h2>11. 리턴값 변조 (인증 우회)</h2>
<pre><code>onLeave: function (retval) {
    retval.replace(1); // JNI_TRUE
}
</code></pre>
<hr>
<h2>12. strcmp 전역 후킹</h2>
<pre><code>var strcmpAddr = Module.findGlobalExportByName("strcmp");

Interceptor.attach(strcmpAddr, {
    onEnter: function (args) {
        var a = args[0].readCString();
        var b = args[1].readCString();
    },
    onLeave: function (retval) {
        retval.replace(0);
    }
});
</code></pre>
<hr>
<h2>13. Native 함수 직접 호출</h2>
<pre><code>var nativeFunc = new NativeFunction(
    funcAddr,
    "int",
    ["pointer", "pointer", "pointer"]
);

var ret = nativeFunc(a, b, c);
</code></pre>
<hr>
<h2>14. 함수 완전 교체 (Interceptor.replace)</h2>
<pre><code>var newFunc = new NativeCallback(function () {
    return 1;
}, "int", []);

Interceptor.replace(funcAddr, newFunc);
</code></pre>
<ul>
<li>원본 함수 실행 자체 제거</li>
</ul>
<hr>
<h2>15. Java 후킹과 비교</h2>
<h3>Java</h3>
<pre><code>Java.use("Class").method.implementation = function () {
    return true;
};
</code></pre>
<h3>Native</h3>
<ul>
<li>주소 기반</li>
<li>메모리 직접 제어</li>
</ul>
<hr>
<h2>16. Hook 타이밍 이슈</h2>
<h3>문제</h3>
<ul>
<li><code>-f 패키지명</code> 실행 시
<ul>
<li><code>System.loadLibrary</code> 미실행</li>
<li>lib 주소가 null</li>
</ul>
</li>
</ul>
<h3>해결 방법</h3>
<ul>
<li><code>System.loadLibrary</code> 후킹</li>
<li><code>onCreate</code> 후킹</li>
<li>일정 시간 지연 후 후킹</li>
</ul>
<hr>
<h2>17. 조건 분기 (어셈블리 개념)</h2>
<pre><code>CMP v0, v1
JZ  0x1234   ; 같으면 점프
JNZ 0x1234   ; 다르면 점프
</code></pre>
<p>Java 코드 대응:</p>
<pre><code>if (a == b) {
    // 참
}
</code></pre>
<hr>
<h2>18. 핵심 정리</h2>
<ul>
<li>JNI 분석은 <strong>주소 + 오프셋 사고</strong></li>
<li>Java String ≠ C String</li>
<li>인증/무결성 로직은 Native에 숨겨지는 경우 많음</li>
<li>Ghidra + Frida 조합이 가장 강력</li>
<li>attach = 감시</li>
<li>replace = 완전 대체</li>
</ul>
</div></article></main></div><script src="/_next/static/chunks/webpack-c5f8510880a90daa.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/fff7d7d50ba66cff.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[7690,[],\"\"]\n6:I[5613,[],\"\"]\n9:I[1778,[],\"\"]\na:I[8383,[\"250\",\"static/chunks/250-069982e43c2ae463.js\",\"185\",\"static/chunks/app/layout-10c7e025b6149e17.js\"],\"\"]\nb:I[5250,[\"250\",\"static/chunks/250-069982e43c2ae463.js\",\"931\",\"static/chunks/app/page-e31ae51de7be232e.js\"],\"\"]\nd:I[8955,[],\"\"]\n7:[\"category\",\"Android\",\"d\"]\n8:[\"slug\",\"day16\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fff7d7d50ba66cff.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"TRFLD1MljlsxO-bl3YPbV\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/post/Android/day16\",\"initialTree\":[\"\",{\"children\":[\"post\",{\"children\":[[\"category\",\"Android\",\"d\"],{\"children\":[[\"slug\",\"day16\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"Android\\\",\\\"slug\\\":\\\"day16\\\"}\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"post\",{\"children\":[[\"category\",\"Android\",\"d\"],{\"children\":[[\"slug\",\"day16\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L4\",\"$L5\",null]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\",\"$7\",\"children\",\"$8\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\",\"$7\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              (function() {\\n                try {\\n                  const savedTheme = localStorage.getItem('theme');\\n                  // Default to 'dark' if no save found, ignoring system preference for now to start dark\\n                  const theme = savedTheme || 'dark';\\n                  document.documentElement.setAttribute('data-theme', theme);\\n                } catch (e) {}\\n              })();\\n            \"}}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app-container\",\"children\":[[\"$\",\"$La\",null,{\"categories\":[\"AWS\",\"Android\",\"JAVA\"]}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center min-h-[60vh] text-center px-4\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-4xl font-bold mb-4\",\"children\":\"404 - Not Found\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-500 mb-8\",\"children\":\"요청하신 페이지를 찾을 수 없습니다.\"}],[\"$\",\"$Lb\",null,{\"href\":\"/\",\"className\":\"px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition\",\"children\":\"홈으로 돌아가기\"}]]}],\"notFoundStyles\":[],\"styles\":null}]}]]}]}]]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"f:T1a91,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJNI (Java Native Interface) 정리\u003c/h1\u003e\n\u003ch2\u003e1. JNI 개념\u003c/h2\u003e\n\u003ch3\u003eJNI란?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJava/Kotlin ↔ C/C++\u003c/strong\u003e 를 연결하는 인터페이스\u003c/li\u003e\n\u003cli\u003eAndroid 앱에서 Native 코드(\u003ccode\u003e.so\u003c/code\u003e)를 사용하기 위한 표준 방식\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eJNI를 사용하는 이유\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e성능\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eVM 위가 아닌 Native에서 직접 연산\u003c/li\u003e\n\u003cli\u003e게임, 그래픽, 대규모 연산\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기존 라이브러리 활용\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e이미 만들어진 C/C++ 라이브러리 재사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e메모리 직접 제어\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eGC 영향 없이 직접 관리\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e보안\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eJava 코드보다 리버싱 난이도 상승\u003c/li\u003e\n\u003cli\u003e금융 앱, 게임, 보안 솔루션에서 다수 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e2. Java / Native 실행 구조 비교\u003c/h2\u003e\n\u003ch3\u003eJava / Kotlin\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eJVM 위에서 실행\u003c/li\u003e\n\u003cli\u003eCross-platform\u003c/li\u003e\n\u003cli\u003e코드 하나로 모든 기기에서 실행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNative (C/C++)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eOS / 아키텍처 의존\u003c/li\u003e\n\u003cli\u003e환경별로 빌드 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e| 환경    | 결과           |\r\n| ------- | -------------- |\r\n| Windows | \u003ccode\u003e.exe\u003c/code\u003e, \u003ccode\u003e.dll\u003c/code\u003e |\r\n| Linux   | ELF, \u003ccode\u003e.so\u003c/code\u003e     |\r\n| Android | \u003ccode\u003e.so\u003c/code\u003e (ABI별)  |\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e3. JNI 함수 연결 방식\u003c/h2\u003e\n\u003ch3\u003eJava 쪽\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003epublic native boolean checkPassword(String pw);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eNative 쪽 (기본 네이밍)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eJava_패키지명_클래스명_함수명\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJava_kr_seyong_test_MainActivity_checkPassword\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSystem.load / loadLibrary\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eSystem.loadLibrary(\"test\");   // libtest.so\r\nSystem.load(\"/sdcard/.../libtest.so\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e라이브러리 로딩 시 \u003ccode\u003eJNI_OnLoad\u003c/code\u003e 실행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e4. RegisterNative 방식\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e함수 이름을 직접 매핑\u003c/li\u003e\n\u003cli\u003eJava 함수명 ≠ Native 함수명 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eJNI_OnLoad() {\r\n    RegisterNativeMethods(\r\n        Java test() → C qqqq()\r\n    );\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eGhidra에서 함수명이 난독화되어 보이는 이유\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e5. Android / iOS 리버싱 구조 비교\u003c/h2\u003e\n\u003ch3\u003eAndroid\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAPK = ZIP\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclasses.dex → smali → java (jadx)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eNative: \u003ccode\u003e.so\u003c/code\u003e → Ghidra / IDA\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eiOS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIPA = ZIP\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInfo.plist\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eBinary 추출 후 Ghidra / IDA\u003c/li\u003e\n\u003cli\u003e탈옥 환경: Cydia, Zebra, Sileo\u003c/li\u003e\n\u003cli\u003e설치: appinst, 3uTools, appsync\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e6. Native 메모리 구조와 Offset\u003c/h2\u003e\n\u003ch3\u003e메모리 배치 개념\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003elibc.so        libandroid.so        libtest.so\r\n[            ][                  ][            ]\r\nbase                            base\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eOffset 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ebase 주소로부터 떨어진 거리\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e실제 함수 주소 = module.base + offset\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebase   = 0x00100000\r\noffset = 0x000243c0\r\naddr   = 0x001243c0\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e7. JNI Native 코드 예제 (Ghidra 기준)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003ebool Java_kr_seyong_test_MainActivity_checkPassword(\r\n    JNIEnv *env,\r\n    jobject thiz,\r\n    jstring pw\r\n) {\r\n    int ret;\r\n    char* nativeStr;\r\n\r\n    nativeStr = env-\u003eGetStringUTFChars(pw, 0);\r\n    ret = strcmp(nativeStr, \"hacker\");\r\n    env-\u003eReleaseStringUTFChars(pw, nativeStr);\r\n\r\n    return ret == 0;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e핵심\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ejstring → char*\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estrcmp\u003c/code\u003e 결과로 인증 판단\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e8. Frida Native 후킹 기본 구조\u003c/h2\u003e\n\u003ch3\u003e라이브러리 \u0026#x26; 함수 주소 찾기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003evar lib = Process.findModuleByName(\"libtest.so\");\r\n\r\n// 1. 함수명 기반\r\nvar funcAddr = lib.findExportByName(\r\n  \"Java_kr_seyong_test_MainActivity_checkPassword\"\r\n);\r\n\r\n// 2. 오프셋 기반\r\nvar funcAddr = lib.base.add(0x243c0);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e9. Interceptor.attach (함수 후킹)\u003c/h2\u003e\n\u003ch3\u003e실행 흐름\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eonEnter\u003c/strong\u003e: 함수 진입 시\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eonLeave\u003c/strong\u003e: 리턴 직전\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eInterceptor.attach(funcAddr, {\r\n    onEnter: function (args) {\r\n        /*\r\n          args[0] = JNIEnv*\r\n          args[1] = jobject (this)\r\n          args[2] = jstring (pw)\r\n        */\r\n    },\r\n    onLeave: function (retval) {\r\n    }\r\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e10. jstring 값 읽기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar env = Java.vm.getEnv();\r\nvar pw = env.getStringUtfChars(args[2], null).readCString();\r\nconsole.log(pw);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e11. 리턴값 변조 (인증 우회)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eonLeave: function (retval) {\r\n    retval.replace(1); // JNI_TRUE\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e12. strcmp 전역 후킹\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar strcmpAddr = Module.findGlobalExportByName(\"strcmp\");\r\n\r\nInterceptor.attach(strcmpAddr, {\r\n    onEnter: function (args) {\r\n        var a = args[0].readCString();\r\n        var b = args[1].readCString();\r\n    },\r\n    onLeave: function (retval) {\r\n        retval.replace(0);\r\n    }\r\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e13. Native 함수 직접 호출\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar nativeFunc = new NativeFunction(\r\n    funcAddr,\r\n    \"int\",\r\n    [\"pointer\", \"pointer\", \"pointer\"]\r\n);\r\n\r\nvar ret = nativeFunc(a, b, c);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e14. 함수 완전 교체 (Interceptor.replace)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar newFunc = new NativeCallback(function () {\r\n    return 1;\r\n}, \"int\", []);\r\n\r\nInterceptor.replace(funcAddr, newFunc);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e원본 함수 실행 자체 제거\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e15. Java 후킹과 비교\u003c/h2\u003e\n\u003ch3\u003eJava\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eJava.use(\"Class\").method.implementation = function () {\r\n    return true;\r\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eNative\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e주소 기반\u003c/li\u003e\n\u003cli\u003e메모리 직접 제어\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e16. Hook 타이밍 이슈\u003c/h2\u003e\n\u003ch3\u003e문제\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-f 패키지명\u003c/code\u003e 실행 시\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSystem.loadLibrary\u003c/code\u003e 미실행\u003c/li\u003e\n\u003cli\u003elib 주소가 null\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e해결 방법\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSystem.loadLibrary\u003c/code\u003e 후킹\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eonCreate\u003c/code\u003e 후킹\u003c/li\u003e\n\u003cli\u003e일정 시간 지연 후 후킹\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e17. 조건 분기 (어셈블리 개념)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eCMP v0, v1\r\nJZ  0x1234   ; 같으면 점프\r\nJNZ 0x1234   ; 다르면 점프\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJava 코드 대응:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif (a == b) {\r\n    // 참\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e18. 핵심 정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eJNI 분석은 \u003cstrong\u003e주소 + 오프셋 사고\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eJava String ≠ C String\u003c/li\u003e\n\u003cli\u003e인증/무결성 로직은 Native에 숨겨지는 경우 많음\u003c/li\u003e\n\u003cli\u003eGhidra + Frida 조합이 가장 강력\u003c/li\u003e\n\u003cli\u003eattach = 감시\u003c/li\u003e\n\u003cli\u003ereplace = 완전 대체\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"article-container\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":\"Android\"}],[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Android 보안 16일차\"}]]}],[\"$\",\"div\",null,{\"className\":\"article-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]]}]\nc:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"titl"])</script><script>self.__next_f.push([1,"e\",\"2\",{\"children\":\"jinwk note\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"jinwk dev note\"}]]\n4:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>